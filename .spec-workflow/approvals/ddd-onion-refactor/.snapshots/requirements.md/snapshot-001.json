{
  "id": "snapshot_1765611896807_zm1j20c3k",
  "approvalId": "approval_1765611896800_k4m9nt8wv",
  "approvalTitle": "DDD + Onion Architecture 改良の要件定義書レビュー",
  "version": 1,
  "timestamp": "2025-12-13T07:44:56.807Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# 要件定義書（Requirements Document）\n\n## Introduction\n\n本ドキュメントは、`lyric-talk`（日本語歌詞を素材として入力文を“歌詞断片の組み合わせ”で再現するCLIツール）を、**DDD（Domain-Driven Design） + Onion Architecture** に沿った構造へ段階的に改良するための要件を定義します。\n\n現状は PoC 的な「CLI → 解析/インデックス化 → マッチング → JSON 出力」の直列パイプラインで実装されており、外部技術（spaCy/GiNZA、ファイルI/O、設定）とドメインロジックが近接しています。本改良の主目的は、\n\n- 依存方向（外側 → 内側）を明確化し、**ドメインを外部技術から隔離**する\n- ユースケース境界を明確化し、**テスト容易性**を高める\n- 将来的拡張（例: 意味的類似、言い換え、永続化）を「差し替え可能なアダプタ」として実装できる土台を作る\n\nことです。\n\n### 対象範囲（In Scope）\n\n- `src/` 配下を Onion のレイヤに沿って再編（例: `domain/`, `application/`, `infrastructure/`, `interface/`）\n- 既存機能（歌詞インデックス化、優先度付きマッチング、JSON出力）の挙動互換を維持\n- テスト基盤（pytest）を追加し、主要ロジックをユニットテスト可能にする\n\n### 非対象（Out of Scope）\n\n- マッチング精度の大幅な改善や新アルゴリズム導入（本件は「構造改善」が主）\n- Web UI / サーバ化\n- 外部サービス（ネットワーク）連携を前提とした機能\n\n## Alignment with Product Vision\n\n本改良は `.spec-workflow/steering/product.md` の原則に整合します。\n\n- **Explainability First**: 一致根拠（どの歌詞トークン/行から採ったか、モーラ内訳）を、構造変更後も出力できるようにする\n- **Japanese-aware Matching**: 表層形・読み・モーラという日本語特有の手がかりを、ドメインの概念として明示し扱いやすくする\n- **Reproducibility & Configurability**: 設定値（例: `max_mora_length`）が結果にどう影響するかをユースケース境界で統制し、同一入力で同一結果が得られる設計を保つ\n\n## Requirements\n\n### Requirement 1 — Onionレイヤ構造の導入\n\n**User Story:** As a 開発者, I want Onion Architecture に沿ったディレクトリ/依存関係を導入したい, so that 変更容易性とテスト容易性を高められる\n\n#### Acceptance Criteria\n\n1. WHEN ソースコードを `src/domain`, `src/application`, `src/infrastructure`, `src/interface` に再編する THEN 依存方向は外側→内側に限定され、内側（domain/application）は外側（infrastructure/interface）を import しない SHALL\n2. WHEN `src/domain` を単独で import する THEN `spacy`, `pydantic_settings`, `argparse`, ファイルI/O 等の外部技術に依存しない SHALL\n3. IF 既存の `lyric-talk = \"src.main:main\"` エントリポイントを維持する必要がある THEN `src/main.py` は互換ラッパ（adapter）として動作し、実処理は interface/application 側へ委譲する SHALL\n\n### Requirement 2 — ドメインモデルの明確化（値オブジェクト/エンティティ）\n\n**User Story:** As a 開発者, I want 歌詞・トークン・読み・モーラ・マッチ結果をドメイン概念として定義したい, so that ビジネスルールが外部技術から独立して理解できる\n\n#### Acceptance Criteria\n\n1. WHEN 「読み」「モーラ」「トークン」「歌詞コーパス」「マッチ結果」などの概念を定義する THEN それらは `src/domain` に配置され、I/O やNLP実装詳細を含まない SHALL\n2. WHEN ドメインロジック（例: 読み正規化、モーラ分割、マッチ結果の表現）を実装する THEN その入出力は純粋データ（primitive/ dataclass 等）で表現され、外部ライブラリ型（例: spaCy Token）を露出しない SHALL\n\n### Requirement 3 — ユースケース（Application層）の導入\n\n**User Story:** As a 開発者, I want 「歌詞インデックス構築」「入力文マッチング」「結果生成」をユースケースとして分離したい, so that 仕様変更とテストが局所化できる\n\n#### Acceptance Criteria\n\n1. WHEN 歌詞インデックス構築を行う THEN Application層のユースケース（例: `BuildLyricIndex`）が Domain モデルを生成する SHALL\n2. WHEN 入力文マッチングを行う THEN Application層のユースケース（例: `MatchTextToLyrics`）が Domain のポリシー（優先度: 表層形→読み→モーラ）に従って結果を生成する SHALL\n3. IF NLP トークナイズ/読み取得の実装を差し替える必要がある THEN Application層は Port（インターフェース）経由で利用し、具体実装は Infrastructure に置く SHALL\n\n### Requirement 4 — Port/Adapter（依存性逆転）の導入\n\n**User Story:** As a 開発者, I want spaCy/GiNZA やファイルI/Oをアダプタとして差し替え可能にしたい, so that 将来の拡張やテスト用の代替実装が容易になる\n\n#### Acceptance Criteria\n\n1. WHEN Application層が「形態素解析・読み取得」を必要とする THEN `NlpPort`（名称は任意）を介して呼び出す SHALL\n2. WHEN Application層が「歌詞入力」「結果出力」を必要とする THEN `LyricsSourcePort` / `ResultSinkPort`（名称は任意）を介して呼び出す SHALL\n3. IF テストで外部依存を排除したい THEN fake/stub 実装を用いてユースケースが実行できる SHALL\n\n### Requirement 5 — CLI互換の維持（Interface層）\n\n**User Story:** As a ユーザー, I want 既存CLIの使い方を変えずに利用したい, so that 破壊的変更なくアップデートできる\n\n#### Acceptance Criteria\n\n1. WHEN ユーザーが `--lyrics` または `--lyrics-text` と `--text` を指定して実行する THEN 従来どおりマッチングが実行され、結果がJSONに出力される SHALL\n2. WHEN `--max-mora-length` を指定する THEN その値がマッチングに反映される SHALL\n3. IF 引数のバリデーションエラーが発生する THEN CLI はユーザーに理解可能なメッセージを表示し、異常終了する SHALL\n\n### Requirement 6 — 出力（JSON）互換と説明可能性の維持\n\n**User Story:** As a ユーザー, I want 出力JSONが従来と同等の情報量と追跡可能性を持ってほしい, so that 結果の根拠を確認できる\n\n#### Acceptance Criteria\n\n1. WHEN マッチングが完了する THEN 出力には少なくとも以下の情報が含まれる SHALL\n   - metadata（timestamp, input_text, settings 等）\n   - input_stats（トークン数等）\n   - results（matched_text, matched_tokens, summary）\n2. WHEN トークンが一致する THEN どのマッチ方式（表層形/読み/モーラ/不一致）かが出力できる SHALL\n3. WHEN モーラ組み合わせが発生する THEN 元トークンの根拠（行番号など）を追跡できる情報が出力できる SHALL\n\n### Requirement 7 — 段階的移行（リファクタリングの安全性）\n\n**User Story:** As a 開発者, I want 段階的に移行できる計画を持ちたい, so that 小さな変更で安全に改善できる\n\n#### Acceptance Criteria\n\n1. WHEN レイヤ分割を進める THEN 1コミット（または1タスク）あたりの変更範囲は小さく保たれる（例: 1〜3ファイル中心） SHALL\n2. IF 既存の公開I/F（エントリポイントや主要クラス）を変更する必要がある THEN 互換ラッパまたは移行ガイドを提供する SHALL\n\n### Requirement 8 — テストと静的解析の前提化\n\n**User Story:** As a 開発者, I want リファクタ中に挙動退行を検知したい, so that 安心して構造変更を進められる\n\n#### Acceptance Criteria\n\n1. WHEN ユニットテストを実行する THEN `uv run pytest` でテストが実行できる SHALL\n2. WHEN リント/フォーマットを実行する THEN `uv run ruff check .` / `uv run ruff check . --fix` で問題が検出・修正できる SHALL\n3. IF ドメイン/ユースケースを変更する THEN 対応するテストが追加/更新される SHALL\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **依存方向の一貫性**: 内側（Domain/Application）は外側（Infrastructure/Interface）に依存しない\n- **単一責務**: 1モジュール1責務（例: モーラ処理、インデックス構築、マッチング、I/O）\n- **明確な契約**: Port（インターフェース）/DTO を介し、レイヤ間のデータ形式を明示する\n- **置換可能性**: NLP や入出力を差し替え可能にし、将来の拡張（埋め込み/永続化）に備える\n\n### Performance\n\n- spaCy + GiNZA のロードを必要以上に繰り返さない（プロセス内での再利用を前提）\n- 構造変更により、典型的入力（数百〜数千トークン）での体感性能を著しく悪化させない\n\n### Security\n\n- デフォルトでネットワーク送信を行わない（ローカル処理を維持）\n- 入力テキストは任意文字列であるため、パス取り扱い・ファイル出力は安全なデフォルトを維持する\n\n### Reliability\n\n- 同一入力（歌詞・設定・入力文）に対して同一結果を返す（再現性）\n- エラー時の例外は握りつぶさず、CLI として適切に通知する\n\n### Usability\n\n- CLIヘルプ（`-h/--help`）で引数の意味が理解できる\n- 出力JSONはユーザーが後処理しやすい構造（機械可読、説明可能）を維持する\n",
  "fileStats": {
    "size": 9845,
    "lines": 146,
    "lastModified": "2025-12-13T07:44:53.539Z"
  },
  "comments": []
}