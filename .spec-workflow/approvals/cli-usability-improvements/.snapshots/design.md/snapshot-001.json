{
  "id": "snapshot_1766219836786_vaxrw77mm",
  "approvalId": "approval_1766219836780_vt781q4de",
  "approvalTitle": "設計: cli-usability-improvements",
  "version": 1,
  "timestamp": "2025-12-20T08:37:16.786Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\n本設計は、`lyric-talk` CLI のユーザービリティ改善を目的として、以下を実現する。\n\n- `match` 実行時に `corpus_id` が省略された場合、コーパス一覧を提示して対話的に選択できる（Requirement 1）\n- `query` 実行時に `run_id` が省略された場合、実行履歴一覧を提示して対話的に選択できる（Requirement 2）\n- 一覧/参照/削除など CLI で必要になる読み取り系処理を、Interface 層に散らばらせず Application UseCase として整備する（Requirement 3）\n- CLI 実装を **Typer + Rich** に刷新し、ヘルプ・入力バリデーション・一覧表示・対話選択の UX と型安全性を向上する（Requirement 4）\n- UseCase 入出力を DTO で明確化し、`dict[str, Any]` ベースの曖昧さを排除する（Requirement 6）\n- 既存の `match corpus_id` / `query run_id` 指定による利用は維持する（Requirement 5）\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **DDD + Onion Architecture** の依存方向を維持する（Interface → Application → Domain、Infrastructure は Domain へ依存しない）。\n- UseCase は Application 層に置き、CLI は「入力の解釈・対話・表示」に集中する。\n- DTO は Application 層に置き、Domain モデル（`MatchRun`, `MatchResult`, `LyricsCorpus` 等）を CLI 表示に直接露出させない。\n- 依存管理は `uv` を前提とし、テストは `pytest`、静的解析/整形は `ruff` に従う。\n\n### Project Structure (structure.md)\n\n- 追加/変更は既存の層構造に従う。\n  - `src/application/use_cases/` に一覧/参照/削除系 UseCase を追加\n  - `src/application/dtos/` に CLI 表示・入出力に必要な DTO を追加\n  - `src/interface/cli/` に Typer + Rich ベースの CLI を実装（既存 `main.py` を置換/移行）\n  - 必要なら `src/domain/repositories/` に一覧取得・件数取得などの抽象メソッドを追加し、`src/infrastructure/database/` の DuckDB 実装に反映\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`RegisterLyricsUseCase` / `MatchTextUseCase` / `QueryResultsUseCase`**: コアユースケースは流用しつつ、一覧選択や DTO 化に合わせて拡張する。\n- **Repository 実装**\n  - `DuckDBLyricsRepository` / `DuckDBMatchRepository` / `DuckDBLyricTokenRepository`\n  - 既存の `find_by_id` / `save` / `delete` を維持しつつ、一覧/サマリー取得向けのメソッドを追加する。\n- **ドメインモデル**\n  - `MatchResult` は `input_token` / `input_reading` / `match_type` / `matched_token_ids` / `mora_details` を既に保持しているため、説明可能な表示の土台として活用できる。\n\n### Integration Points\n\n- **Database/Storage**\n  - `lyrics_corpus`, `lyric_tokens`, `match_runs`, `match_results` 既存スキーマを利用\n  - 一覧表示のため、全件ロードを避けた「サマリー取得」を SQL で行えるよう repository API を設計する\n- **CLI Entry Point**\n  - `pyproject.toml` の entry point `lyric-talk = \"src.interface.cli.main:main\"` は維持し、`main()` 内部で Typer アプリを起動する\n\n## Architecture\n\n### High-level flow\n\n- `match`:\n  1) `corpus_id` が指定されていればそのまま `MatchTextUseCase.execute(input_text, corpus_id)`\n  2) 省略されていれば `ListLyricsCorporaUseCase` で候補一覧 → 対話選択 → 1)へ\n\n- `query`:\n  1) `run_id` が指定されていれば `QueryResultsUseCase`（後述の DTO 版）で結果取得\n  2) 省略されていれば `ListMatchRunsUseCase` で候補一覧 → 対話選択 → 1)へ\n\n- 非対話環境（stdin が TTY でない等）の場合:\n  - `corpus_id` / `run_id` 省略時に対話へフォールバックせず、明確なエラーと非ゼロ終了コードで終了する（Requirement 4-5, Reliability）\n\n```mermaid\ngraph TD\n  CLI[Typer CLI + Rich UI] -->|call| U1[ListLyricsCorporaUseCase]\n  CLI -->|call| U2[ListMatchRunsUseCase]\n  CLI -->|call| U3[MatchTextUseCase]\n  CLI -->|call| U4[QueryResultsUseCase v2 (DTO)]\n\n  U1 --> LR[LyricsRepository]\n  U1 --> TR[LyricTokenRepository]\n\n  U2 --> MR[MatchRepository]\n\n  U3 --> TR\n  U3 --> MR\n\n  U4 --> MR\n  U4 --> TR\n\n  LR -.implemented by.-> DLR[DuckDBLyricsRepository]\n  TR -.implemented by.-> DTR[DuckDBLyricTokenRepository]\n  MR -.implemented by.-> DMR[DuckDBMatchRepository]\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**\n  - DTO 定義は `src/application/dtos/` に集約\n  - UseCase は「取得/整形の責務」を持ち、CLI は表示に特化\n- **Service Layer Separation**\n  - Repository は「永続化・検索」のみ\n  - UseCase は「ユースケース境界（一覧/参照/削除・整形DTO）」\n  - CLI は「引数解釈、対話、表示、終了コード」\n\n## Components and Interfaces\n\n### Component 1: `ListLyricsCorporaUseCase`\n\n- **Purpose:** コーパス一覧（CLI 表示に必要な概要）を取得する（Requirement 1, 3）\n- **Interface:**\n  - `execute(limit: int = 20) -> list[LyricsCorpusSummaryDto]`\n- **Dependencies:** `LyricsRepository`, `LyricTokenRepository`\n- **Reuses:** `LyricsCorpus`（メタデータ）\n\n#### Repository 拡張（案）\n\n- `LyricsRepository.list_recent(limit: int) -> list[LyricsCorpus]`\n- `LyricTokenRepository.count_by_lyrics_corpus_id(corpus_id: str) -> int`\n- `LyricTokenRepository.preview_by_lyrics_corpus_id(corpus_id: str, limit_tokens: int) -> list[LyricToken]`\n\n### Component 2: `ListMatchRunsUseCase`\n\n- **Purpose:** 実行履歴一覧（CLI 表示に必要な概要）を取得する（Requirement 2, 3）\n- **Interface:**\n  - `execute(limit: int = 20) -> list[MatchRunSummaryDto]`\n- **Dependencies:** `MatchRepository`\n\n#### Repository 拡張（案）\n\n- `MatchRepository.list_recent(limit: int) -> list[MatchRun]`（※results はロードしない or 空で返す）\n- `MatchRepository.count_results_by_run_id(run_id: str) -> int`（一覧表示用）\n\n### Component 3: `QueryResultsUseCase` v2（DTO 化）\n\n- **Purpose:** `run_id` の結果を「判読可能な構造」で返す（Requirement 2, 6）\n- **Interface:**\n  - `execute(run_id: str) -> QueryResultsDto | None`\n\n#### DTO 化のポイント\n\n- 返り値を `dict` ではなく `QueryResultsDto`（pydantic）に置換する\n- 表示に必要な「解決済み情報」を DTO に含める\n  - 入力トークン（表層/読み）\n  - `match_type`\n  - 採用された歌詞トークン（表層/読み/lemma/pos 等、必要最小限）\n  - `mora_combination` の根拠（`mora_details` をトレース可能に整形）\n  - サマリー（再構成テキスト）\n\n### Component 4: Typer + Rich CLI (`src/interface/cli/main.py`)\n\n- **Purpose:** UX の高い CLI（help、型安全な引数、エラー表示、一覧、対話選択）を提供する（Requirement 4, 5）\n- **Interfaces (commands):**\n  - `lyric-talk register`（現状維持、help 改善）\n  - `lyric-talk match [CORPUS_ID?] (--text/FILE)`\n  - `lyric-talk query [RUN_ID?]`\n  - 追加（設計で提供する）\n    - `lyric-talk corpus list` / `lyric-talk run list`（非対話でも一覧取得可能にする）\n    - `delete` 系は optional（Requirement 3-6）\n\n#### 非対話対応\n\n- `--corpus-id` / `--run-id` が未指定で、対話が必要なのに TTY でない場合は、\n  - 「ID を指定して再実行する」または「list コマンドを使う」ガイダンスを表示して終了\n\n## Data Models\n\n### `LyricsCorpusSummaryDto`（Application DTO）\n\n- `lyrics_corpus_id: str`\n- `title: str | None`\n- `artist: str | None`\n- `created_at: datetime`\n- `token_count: int`\n- `preview_text: str`（先頭 N トークンの連結 or サンプル）\n\n### `MatchRunSummaryDto`（Application DTO）\n\n- `run_id: str`\n- `lyrics_corpus_id: str`\n- `timestamp: datetime`\n- `input_text_preview: str`（先頭 N 文字）\n- `results_count: int`\n\n### `QueryResultsDto`（Application DTO）\n\n- `match_run: MatchRunMetaDto`（run_id, corpus_id, timestamp, input_text, config）\n- `items: list[QueryMatchItemDto]`\n- `summary: QuerySummaryDto`\n\n#### `QueryMatchItemDto` の要素（例）\n\n- `input: InputTokenDto`（surface, reading）\n- `match_type: MatchType`\n- `chosen_lyrics_tokens: list[LyricTokenDto]`（surface, reading, lemma, pos, token_id など必要最小限）\n- `mora_trace: MoraTraceDto | None`\n\n#### `QuerySummaryDto`（例）\n\n- `reconstructed_surface: str`（可能な範囲で「採用されたトークン」を連結）\n- `reconstructed_reading: str`（`mora_details` 等から再構成）\n- `stats: MatchStatsDto`（match_type 別件数など）\n\n## Error Handling\n\n### Error Scenarios\n\n1. **コーパスが0件で match の corpus_id が省略された**\n   - **Handling:** `ListLyricsCorporaUseCase` が空を返す → CLI が「先に register が必要」を Rich で表示\n   - **User Impact:** 明確なメッセージ + 非ゼロ終了コード\n\n2. **実行履歴が0件で query の run_id が省略された**\n   - **Handling:** `ListMatchRunsUseCase` が空を返す → CLI が「先に match が必要」を表示\n   - **User Impact:** 明確なメッセージ + 非ゼロ終了コード\n\n3. **非対話環境で ID 省略が発生した**\n   - **Handling:** 対話に入らず、`--corpus-id/--run-id` 指定や `list` コマンドの利用を促して終了\n   - **User Impact:** ハングしない（CI 安全）\n\n4. **存在しない corpus_id/run_id を指定した**\n   - **Handling:** UseCase が `None` / NotFound を返す → CLI が「どの ID が不正か」「どう直すか」を表示\n   - **User Impact:** ガイダンス付きエラー\n\n## Testing Strategy\n\n### Unit Testing\n\n- Application:\n  - `ListLyricsCorporaUseCase`（0/1/複数件、token_count/preview の生成）\n  - `ListMatchRunsUseCase`（0/複数件、ソート、results_count）\n  - `QueryResultsUseCase v2`（`exact_surface` / `exact_reading` / `mora_combination` を含む DTO 生成、サマリー生成）\n\n### Integration Testing\n\n- DuckDB 実装を使った「register → match → query」フロー\n- 一覧 API（list_recent 等）の SQL がスキーマと整合していること\n\n### End-to-End Testing\n\n- Typer CLI のコマンド単位テスト（引数バリデーション、help、非対話でのエラー分岐）\n- 対話選択は、可能なら Typer のテストユーティリティや stdin 差し替えで最小限を検証し、\n  非対話エラー経路を重点的に担保する\n",
  "fileStats": {
    "size": 10584,
    "lines": 235,
    "lastModified": "2025-12-20T08:37:05.185Z"
  },
  "comments": []
}